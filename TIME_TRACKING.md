# Time Tracking System: Микросервисный подход

## 1. Миссия и Философия

Этот документ описывает архитектуру и принципы работы **независимого, переиспользуемого сервиса** для отслеживания времени.

**Миссия:** Создать отдельный, самодостаточный инструмент, способный обслуживать **любую** внешнюю систему, предоставляя ей API для логирования временных затрат. Сервис ничего не знает о бизнес-логике систем-потребителей ("пироги", "сапоги") и оперирует только абстрактными идентификаторами.

Это реализация принципа "Время-Деньги" как универсального, платформенно-независимого решения.

## 2. Архитектура: "Универсальный Указатель"

В основе лежит принцип **полиморфной ассоциации**. Сервис не имеет жестких связей с таблицами систем-потребителей. Вместо этого он хранит универсальные указатели на сущности в этих системах.

### 2.1. Стек технологий
*   **Среда выполнения:** `Node.js` (рекомендуемая версия v24.3.0 или выше).
*   **База данных:** Встроенная `SQLite` через нативный драйвер `node:sqlite`. Это обеспечивает максимальную портативность и простоту развертывания без необходимости поднимать отдельный сервер БД.
*   **API:** RESTful API для взаимодействия с внешними системами.

### 2.2. Схема базы данных сервиса

**Таблица `log_step` (Справочник шагов):**
*   **Назначение:** Опциональная таблица для хранения предопределенных шагов, если сервис используется в рамках одной экосистемы. Может не использоваться, если системы-потребители передают `step_name` как строку.
*   **Структура:**
    | Название колонки | Тип данных | Описание                                  |
    |:-----------------|:-----------|:------------------------------------------|
    | `id`             | `INTEGER`  | Primary Key.                              |
    | `step_name`      | `TEXT`     | Уникальное кодовое имя (`product_research`).|

**Таблица `time_log` (Журнал времени):**
*   **Назначение:** Основная таблица для хранения всех временных логов.
*   **Структура:**
    | Название колонки   | Тип данных | Описание                                      |
    |:-------------------|:-----------|:----------------------------------------------|
    | `id`               | `INTEGER`  | Primary Key.                                  |
    | `target_system`    | `TEXT`     | Имя системы-потребителя ('order-system').     |
    | `target_entity_name`|`TEXT`     | Имя сущности в той системе ('product', 'order'). |
    | `target_entity_id` | `TEXT`     | ID сущности в той системе (может быть не-числовым). |
    | `step_name`        | `TEXT`     | Название шага (передается от клиента).        |
    | `context_json`     | `JSON`     | **"Что-как-начто-кто"**: JSON объект для доп. контекста. |
    | `start_ts`         | `DATETIME` | Начало.                                       |
    | `end_ts`           | `DATETIME` | Окончание.                                    |
    | `duration_minutes` | `INTEGER`  | Длительность.                                 |
    | `notes`            | `TEXT`     | Заметки.                                      |

### 2.3. Принцип работы
1.  **API-first:** Взаимодействие с сервисом происходит исключительно через API.
2.  **Полиморфная связь:** Связь с объектом логирования (`target_*`) полностью абстрактна. Целостность данных (проверка существования `target_entity_id`) является ответственностью системы-клиента.
3.  **Изоляция:** Сервис полностью изолирован и может быть развернут где угодно.

## 3. Плюсы и минусы

*   **Плюсы:**
    *   **Максимальная гибкость и переиспользуемость:** Может обслуживать неограниченное количество разных систем.
    *   **Независимость:** Не требует знаний о схемах данных клиентов.
    *   **Масштабируемость:** Легко масштабируется как отдельный компонент.
*   **Минусы:**
    *   **Отсутствие контроля целостности:** Нет `FOREIGN KEY`, что создает риск "битых" ссылок.
    *   **Усложненная аналитика:** Требует выгрузки и объединения данных из нескольких систем для получения полной картины.
    *   **Более сложная первоначальная настройка:** Требует развертывания отдельного сервиса.